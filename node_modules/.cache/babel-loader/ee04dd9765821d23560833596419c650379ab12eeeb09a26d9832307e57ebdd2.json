{"ast":null,"code":"import { useMemo as e, createElement as r, memo as t, useState as n, useCallback as o, Fragment as i } from \"react\";\nimport { useTheme as a, useMotionConfig as l, useAnimatedPath as d, positionFromAngle as u, radiansToDegrees as c, usePropertyAccessor as s, DotsItem as f, useValueFormatter as m, degreesToRadians as g, bindDefs as v, useCurveInterpolation as y, Container as h, useDimensions as p, SvgWrapper as b, ResponsiveWrapper as x } from \"@nivo/core\";\nimport { BoxLegendSvg as k } from \"@nivo/legends\";\nimport { useSpring as B, animated as L, useSprings as S, to as C } from \"@react-spring/web\";\nimport { lineRadial as O, curveLinearClosed as I, arc as M } from \"d3-shape\";\nimport { useInheritedColor as W, getInheritedColorGenerator as K, useOrdinalColorScale as V } from \"@nivo/colors\";\nimport { jsx as D, Fragment as Y, jsxs as w } from \"react/jsx-runtime\";\nimport { useTooltip as A, Chip as F, TableTooltip as P } from \"@nivo/tooltip\";\nimport { scaleLinear as X } from \"d3-scale\";\nfunction z() {\n  return z = Object.assign ? Object.assign.bind() : function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n    }\n    return e;\n  }, z.apply(this, arguments);\n}\nfunction j(e, r) {\n  if (null == e) return {};\n  var t,\n    n,\n    o = {},\n    i = Object.keys(e);\n  for (n = 0; n < i.length; n++) t = i[n], r.indexOf(t) >= 0 || (o[t] = e[t]);\n  return o;\n}\nvar T = function (r) {\n    var t,\n      n = r.data,\n      o = r.item,\n      i = r.colorByKey,\n      u = r.fillByKey,\n      c = r.radiusScale,\n      s = r.rotation,\n      f = r.angleStep,\n      m = r.curveFactory,\n      g = r.borderWidth,\n      v = r.borderColor,\n      y = r.fillOpacity,\n      h = r.blendMode,\n      p = a(),\n      b = W(v, p),\n      x = e(function () {\n        return O().radius(function (e) {\n          return c(e);\n        }).angle(function (e, r) {\n          return s + r * f;\n        }).curve(m);\n      }, [c, s, f, m]),\n      k = l(),\n      S = k.animate,\n      C = k.config,\n      I = d(x(n.map(function (e) {\n        return e[o];\n      }))),\n      M = B({\n        fill: i[o],\n        stroke: b({\n          key: o,\n          color: i[o]\n        }),\n        config: C,\n        immediate: !S\n      }),\n      K = null != (t = u[o]) ? t : M.fill;\n    return D(L.path, {\n      d: I,\n      fill: K,\n      fillOpacity: y,\n      stroke: M.stroke,\n      strokeWidth: g,\n      style: {\n        mixBlendMode: h\n      }\n    }, o);\n  },\n  E = function (e) {\n    var t = e.radius,\n      n = e.angles,\n      o = e.indices,\n      i = e.label,\n      a = e.labelOffset,\n      d = l(),\n      s = d.animate,\n      f = d.config,\n      m = o.map(function (e, r) {\n        var o,\n          i,\n          l = u(n[r], t + a),\n          d = (o = n[r], (i = c(o) + 90) <= 10 || i >= 350 || i >= 170 && i <= 190 ? \"middle\" : i > 180 ? \"end\" : \"start\");\n        return z({\n          id: e,\n          angle: c(n[r]),\n          anchor: d\n        }, l);\n      }),\n      g = S(m.length, m.map(function (e) {\n        return {\n          transform: \"translate(\" + e.x + \", \" + e.y + \")\",\n          config: f,\n          immediate: !s\n        };\n      }));\n    return D(Y, {\n      children: g.map(function (e, t) {\n        var n = m[t];\n        return r(i, {\n          key: n.id,\n          id: n.id,\n          anchor: n.anchor,\n          angle: n.angle,\n          x: n.x,\n          y: n.y,\n          animated: e\n        });\n      })\n    });\n  },\n  H = [\"shape\"],\n  G = t(function (e) {\n    var r = e.radius,\n      t = a(),\n      n = l(),\n      o = n.animate,\n      i = n.config,\n      d = B({\n        radius: r,\n        config: i,\n        immediate: !o\n      });\n    return D(L.circle, z({\n      fill: \"none\",\n      r: C(d.radius, function (e) {\n        return Math.max(e, 0);\n      })\n    }, t.grid.line));\n  }),\n  R = function (r) {\n    var t = r.radius,\n      n = r.rotation,\n      o = r.angleStep,\n      i = r.dataLength,\n      l = a(),\n      u = e(function () {\n        return O().angle(function (e) {\n          return n + e * o;\n        }).radius(t).curve(I);\n      }, [n, o, t]),\n      c = Array.from({\n        length: i\n      }, function (e, r) {\n        return r;\n      }),\n      s = d(u(c));\n    return D(L.path, z({\n      fill: \"none\",\n      d: s\n    }, l.grid.line));\n  },\n  q = function (e) {\n    var r = e.shape,\n      t = j(e, H);\n    return \"circular\" === r ? D(G, {\n      radius: t.radius\n    }) : D(R, z({}, t));\n  },\n  J = function (r) {\n    var t = r.indices,\n      n = r.levels,\n      o = r.shape,\n      i = r.radius,\n      l = r.rotation,\n      d = r.angleStep,\n      c = r.label,\n      s = r.labelOffset,\n      f = a(),\n      m = e(function () {\n        return {\n          radii: Array.from({\n            length: n\n          }).map(function (e, r) {\n            return i / n * (r + 1);\n          }).reverse(),\n          angles: Array.from({\n            length: t.length\n          }).map(function (e, r) {\n            return l + r * d - Math.PI / 2;\n          })\n        };\n      }, [t, n, i, l, d]),\n      g = m.radii,\n      v = m.angles;\n    return w(Y, {\n      children: [v.map(function (e, r) {\n        var t = u(e, i);\n        return D(\"line\", z({\n          x1: 0,\n          y1: 0,\n          x2: t.x,\n          y2: t.y\n        }, f.grid.line), \"axis.\" + r);\n      }), g.map(function (e, r) {\n        return D(q, {\n          shape: o,\n          radius: e,\n          rotation: l,\n          angleStep: d,\n          dataLength: t.length\n        }, \"level.\" + r);\n      }), D(E, {\n        radius: i,\n        angles: v,\n        indices: t,\n        labelOffset: s,\n        label: c\n      })]\n    });\n  },\n  N = function (t) {\n    var i = t.datum,\n      l = t.keys,\n      d = t.index,\n      c = t.formatValue,\n      s = t.colorByKey,\n      f = t.radius,\n      m = t.startAngle,\n      g = t.endAngle,\n      v = t.arcGenerator,\n      y = t.tooltip,\n      h = t.onClick,\n      p = n(!1),\n      b = p[0],\n      x = p[1],\n      k = a(),\n      B = A(),\n      L = B.showTooltipFromEvent,\n      S = B.hideTooltip,\n      C = o(function (e) {\n        return null == h ? void 0 : h(i, e);\n      }, [h, i]),\n      O = e(function () {\n        var e = l.map(function (e) {\n          return {\n            color: s[e],\n            id: e,\n            value: i[e],\n            formattedValue: c(i[e], e)\n          };\n        });\n        return e.sort(function (e, r) {\n          return e.value - r.value;\n        }), e.reverse(), e;\n      }, [i, l, c, s]),\n      I = o(function (e) {\n        x(!0), L(r(y, {\n          index: d,\n          data: O\n        }), e);\n      }, [L, y, d, O]),\n      M = o(function () {\n        x(!1), S();\n      }, [S, x]),\n      W = e(function () {\n        var e = u(m + .5 * (g - m) - Math.PI / 2, f);\n        return {\n          path: v({\n            startAngle: m,\n            endAngle: g\n          }),\n          tipX: e.x,\n          tipY: e.y\n        };\n      }, [m, g, f, v]),\n      K = W.path,\n      V = W.tipX,\n      F = W.tipY;\n    return w(Y, {\n      children: [b && D(\"line\", {\n        x1: 0,\n        y1: 0,\n        x2: V,\n        y2: F,\n        style: k.crosshair.line\n      }), D(\"path\", {\n        d: K,\n        fill: \"#F00\",\n        fillOpacity: 0,\n        onMouseEnter: I,\n        onMouseMove: I,\n        onMouseLeave: M,\n        onClick: C\n      })]\n    });\n  },\n  Q = function (e) {\n    var r = e.data,\n      t = e.keys,\n      n = e.getIndex,\n      o = e.formatValue,\n      i = e.colorByKey,\n      a = e.radius,\n      l = e.rotation,\n      d = e.angleStep,\n      u = e.tooltip,\n      c = e.onClick,\n      s = M().outerRadius(a).innerRadius(0),\n      f = l - .5 * d;\n    return D(Y, {\n      children: r.map(function (e) {\n        var r = n(e),\n          l = f;\n        return f += d, D(N, {\n          datum: e,\n          keys: t,\n          index: r,\n          formatValue: o,\n          colorByKey: i,\n          startAngle: l,\n          endAngle: l + d,\n          radius: a,\n          arcGenerator: s,\n          tooltip: u,\n          onClick: c\n        }, r);\n      })\n    });\n  },\n  U = function (r) {\n    var t = r.data,\n      n = r.keys,\n      o = r.getIndex,\n      i = r.colorByKey,\n      l = r.radiusScale,\n      d = r.rotation,\n      c = r.angleStep,\n      m = r.symbol,\n      g = r.size,\n      v = void 0 === g ? 6 : g,\n      y = r.color,\n      h = void 0 === y ? {\n        from: \"color\"\n      } : y,\n      p = r.borderWidth,\n      b = void 0 === p ? 0 : p,\n      x = r.borderColor,\n      k = void 0 === x ? {\n        from: \"color\"\n      } : x,\n      B = r.enableLabel,\n      L = void 0 !== B && B,\n      S = r.label,\n      C = void 0 === S ? \"value\" : S,\n      O = r.formatValue,\n      I = r.labelYOffset,\n      M = a(),\n      W = K(h, M),\n      V = K(k, M),\n      w = s(C),\n      A = e(function () {\n        return t.reduce(function (e, r, t) {\n          var a = o(r);\n          return n.forEach(function (n) {\n            var o = r[n],\n              s = {\n                index: a,\n                key: n,\n                value: o,\n                formattedValue: O(o, n),\n                color: i[n]\n              };\n            e.push({\n              key: n + \".\" + a,\n              label: L ? w(s) : void 0,\n              style: z({\n                fill: W(s),\n                stroke: V(s)\n              }, u(d + c * t - Math.PI / 2, l(r[n]))),\n              data: s\n            });\n          }), e;\n        }, []);\n      }, [t, n, o, i, L, w, O, W, V, d, c, l]);\n    return D(Y, {\n      children: A.map(function (e) {\n        return D(f, {\n          x: e.style.x,\n          y: e.style.y,\n          symbol: m,\n          size: v,\n          color: e.style.fill,\n          borderWidth: b,\n          borderColor: e.style.stroke,\n          label: e.label,\n          labelYOffset: I,\n          datum: e.data\n        }, e.key);\n      })\n    });\n  },\n  Z = {\n    layers: [\"grid\", \"layers\", \"slices\", \"dots\", \"legends\"],\n    maxValue: \"auto\",\n    rotation: 0,\n    curve: \"linearClosed\",\n    borderWidth: 2,\n    borderColor: {\n      from: \"color\"\n    },\n    gridLevels: 5,\n    gridShape: \"circular\",\n    gridLabelOffset: 16,\n    gridLabel: function (e) {\n      var r = e.id,\n        t = e.anchor,\n        n = e.animated,\n        o = a();\n      return D(L.g, {\n        transform: n.transform,\n        children: D(\"text\", {\n          style: o.axis.ticks.text,\n          dominantBaseline: \"central\",\n          textAnchor: t,\n          children: r\n        })\n      });\n    },\n    enableDots: !0,\n    dotSize: 6,\n    dotColor: {\n      from: \"color\"\n    },\n    dotBorderWidth: 0,\n    dotBorderColor: {\n      from: \"color\"\n    },\n    enableDotLabel: !1,\n    dotLabel: \"formattedValue\",\n    dotLabelYOffset: -12,\n    colors: {\n      scheme: \"nivo\"\n    },\n    fillOpacity: .25,\n    blendMode: \"normal\",\n    isInteractive: !0,\n    sliceTooltip: function (r) {\n      var t = r.index,\n        n = r.data,\n        o = e(function () {\n          return n.map(function (e) {\n            return [D(F, {\n              color: e.color\n            }, e.id), e.id, e.formattedValue];\n          });\n        }, [n]);\n      return D(P, {\n        title: D(\"strong\", {\n          children: t\n        }),\n        rows: o\n      });\n    },\n    legends: [],\n    role: \"img\",\n    animate: !0,\n    motionConfig: \"gentle\",\n    defs: [],\n    fill: []\n  },\n  $ = [\"data\"],\n  _ = [\"isInteractive\", \"animate\", \"motionConfig\", \"theme\", \"renderWrapper\"],\n  ee = function (t) {\n    var n = t.data,\n      o = t.keys,\n      a = t.indexBy,\n      l = t.layers,\n      d = void 0 === l ? Z.layers : l,\n      u = t.rotation,\n      c = void 0 === u ? Z.rotation : u,\n      f = t.maxValue,\n      h = void 0 === f ? Z.maxValue : f,\n      x = t.valueFormat,\n      B = t.curve,\n      L = void 0 === B ? Z.curve : B,\n      S = t.margin,\n      C = t.width,\n      O = t.height,\n      I = t.borderWidth,\n      M = void 0 === I ? Z.borderWidth : I,\n      W = t.borderColor,\n      K = void 0 === W ? Z.borderColor : W,\n      Y = t.gridLevels,\n      w = void 0 === Y ? Z.gridLevels : Y,\n      A = t.gridShape,\n      F = void 0 === A ? Z.gridShape : A,\n      P = t.gridLabel,\n      E = void 0 === P ? Z.gridLabel : P,\n      H = t.gridLabelOffset,\n      G = void 0 === H ? Z.gridLabelOffset : H,\n      R = t.enableDots,\n      q = void 0 === R ? Z.enableDots : R,\n      N = t.dotSymbol,\n      _ = t.dotSize,\n      ee = void 0 === _ ? Z.dotSize : _,\n      re = t.dotColor,\n      te = void 0 === re ? Z.dotColor : re,\n      ne = t.dotBorderWidth,\n      oe = void 0 === ne ? Z.dotBorderWidth : ne,\n      ie = t.dotBorderColor,\n      ae = void 0 === ie ? Z.dotBorderColor : ie,\n      le = t.enableDotLabel,\n      de = void 0 === le ? Z.enableDotLabel : le,\n      ue = t.dotLabel,\n      ce = void 0 === ue ? Z.dotLabel : ue,\n      se = t.dotLabelYOffset,\n      fe = void 0 === se ? Z.dotLabelYOffset : se,\n      me = t.colors,\n      ge = void 0 === me ? Z.colors : me,\n      ve = t.fillOpacity,\n      ye = void 0 === ve ? Z.fillOpacity : ve,\n      he = t.blendMode,\n      pe = void 0 === he ? Z.blendMode : he,\n      be = t.isInteractive,\n      xe = void 0 === be ? Z.isInteractive : be,\n      ke = t.sliceTooltip,\n      Be = void 0 === ke ? Z.sliceTooltip : ke,\n      Le = t.legends,\n      Se = void 0 === Le ? Z.legends : Le,\n      Ce = t.role,\n      Oe = t.ariaLabel,\n      Ie = t.ariaLabelledBy,\n      Me = t.ariaDescribedBy,\n      We = t.defs,\n      Ke = void 0 === We ? Z.defs : We,\n      Ve = t.fill,\n      De = void 0 === Ve ? Z.fill : Ve,\n      Ye = t.onClick,\n      we = p(C, O, S),\n      Ae = we.margin,\n      Fe = we.innerWidth,\n      Pe = we.innerHeight,\n      Xe = we.outerWidth,\n      ze = we.outerHeight,\n      je = function (r) {\n        var t = r.data,\n          n = r.keys,\n          o = r.indexBy,\n          i = r.rotationDegrees,\n          a = r.maxValue,\n          l = r.valueFormat,\n          d = r.curve,\n          u = r.width,\n          c = r.height,\n          f = r.colors,\n          h = void 0 === f ? Z.colors : f,\n          p = r.legends,\n          b = r.defs,\n          x = r.fill,\n          k = s(o),\n          B = e(function () {\n            return t.map(k);\n          }, [t, k]),\n          L = m(l),\n          S = g(i),\n          C = V(h, \"key\"),\n          O = e(function () {\n            return n.reduce(function (e, r, t) {\n              return e[r] = C({\n                key: r,\n                index: t\n              }), e;\n            }, {});\n          }, [n, C]),\n          I = e(function () {\n            var e = n.map(function (e) {\n                return {\n                  key: e,\n                  color: O[e],\n                  data: t,\n                  fill: null\n                };\n              }),\n              r = v(b, e, x),\n              o = e.reduce(function (e, r) {\n                var t = r.key,\n                  n = r.fill;\n                return e[t] = n, e;\n              }, {});\n            return {\n              boundDefs: r,\n              fillByKey: o\n            };\n          }, [n, t, b, x, O]),\n          M = I.boundDefs,\n          W = I.fillByKey,\n          K = e(function () {\n            var e = t.reduce(function (e, r) {\n                return [].concat(e, n.map(function (e) {\n                  return r[e];\n                }));\n              }, []),\n              r = \"auto\" !== a ? a : Math.max.apply(Math, e),\n              o = Math.min(u, c) / 2;\n            return {\n              radius: o,\n              radiusScale: X().range([0, o]).domain([0, r]),\n              centerX: u / 2,\n              centerY: c / 2,\n              angleStep: 2 * Math.PI / t.length\n            };\n          }, [n, t, a, u, c]),\n          D = K.radius,\n          Y = K.radiusScale,\n          w = K.centerX,\n          A = K.centerY,\n          F = K.angleStep,\n          P = y(d),\n          T = e(function () {\n            return {\n              data: t,\n              keys: n,\n              indices: B,\n              colorByKey: O,\n              centerX: w,\n              centerY: A,\n              radiusScale: Y,\n              angleStep: F\n            };\n          }, [t, n, B, O, w, A, Y, F]),\n          E = e(function () {\n            return n.map(function (e) {\n              return {\n                id: e,\n                label: e,\n                color: O[e]\n              };\n            });\n          }, [n, O]),\n          H = e(function () {\n            return p.map(function (e) {\n              var r = e.data,\n                t = j(e, $),\n                n = null == r ? void 0 : r.map(function (e) {\n                  return z({}, E.find(function (r) {\n                    return r.id === e.id;\n                  }) || {}, e);\n                });\n              return z({}, t, {\n                data: n || E\n              });\n            });\n          }, [p, E]);\n        return {\n          getIndex: k,\n          indices: B,\n          formatValue: L,\n          colorByKey: O,\n          fillByKey: W,\n          boundDefs: M,\n          rotation: S,\n          radius: D,\n          radiusScale: Y,\n          centerX: w,\n          centerY: A,\n          angleStep: F,\n          curveFactory: P,\n          legendData: E,\n          boundLegends: H,\n          customLayerProps: T\n        };\n      }({\n        data: n,\n        keys: o,\n        indexBy: a,\n        rotationDegrees: c,\n        maxValue: h,\n        valueFormat: x,\n        curve: L,\n        width: Fe,\n        height: Pe,\n        colors: ge,\n        legends: Se,\n        defs: Ke,\n        fill: De\n      }),\n      Te = je.getIndex,\n      Ee = je.indices,\n      He = je.formatValue,\n      Ge = je.colorByKey,\n      Re = je.fillByKey,\n      qe = je.boundDefs,\n      Je = je.rotation,\n      Ne = je.radius,\n      Qe = je.radiusScale,\n      Ue = je.centerX,\n      Ze = je.centerY,\n      $e = je.angleStep,\n      _e = je.curveFactory,\n      er = je.boundLegends,\n      rr = je.customLayerProps,\n      tr = {\n        grid: null,\n        layers: null,\n        slices: null,\n        dots: null,\n        legends: null\n      };\n    return d.includes(\"grid\") && (tr.grid = D(\"g\", {\n      transform: \"translate(\" + Ue + \", \" + Ze + \")\",\n      children: D(J, {\n        levels: w,\n        shape: F,\n        radius: Ne,\n        rotation: Je,\n        angleStep: $e,\n        indices: Ee,\n        label: E,\n        labelOffset: G\n      })\n    }, \"grid\")), d.includes(\"layers\") && (tr.layers = D(\"g\", {\n      transform: \"translate(\" + Ue + \", \" + Ze + \")\",\n      children: o.map(function (e) {\n        return D(T, {\n          data: n,\n          item: e,\n          colorByKey: Ge,\n          fillByKey: Re,\n          radiusScale: Qe,\n          rotation: Je,\n          angleStep: $e,\n          curveFactory: _e,\n          borderWidth: M,\n          borderColor: K,\n          fillOpacity: ye,\n          blendMode: pe\n        }, e);\n      })\n    }, \"layers\")), d.includes(\"slices\") && xe && (tr.slices = D(\"g\", {\n      transform: \"translate(\" + Ue + \", \" + Ze + \")\",\n      children: D(Q, {\n        data: n,\n        keys: o,\n        getIndex: Te,\n        formatValue: He,\n        colorByKey: Ge,\n        radius: Ne,\n        rotation: Je,\n        angleStep: $e,\n        tooltip: Be,\n        onClick: Ye\n      })\n    }, \"slices\")), d.includes(\"dots\") && q && (tr.dots = D(\"g\", {\n      transform: \"translate(\" + Ue + \", \" + Ze + \")\",\n      children: D(U, {\n        data: n,\n        keys: o,\n        getIndex: Te,\n        radiusScale: Qe,\n        rotation: Je,\n        angleStep: $e,\n        symbol: N,\n        size: ee,\n        colorByKey: Ge,\n        color: te,\n        borderWidth: oe,\n        borderColor: ae,\n        enableLabel: de,\n        label: ce,\n        formatValue: He,\n        labelYOffset: fe\n      })\n    }, \"dots\")), d.includes(\"legends\") && (tr.legends = D(i, {\n      children: er.map(function (e, r) {\n        return D(k, z({}, e, {\n          containerWidth: C,\n          containerHeight: O\n        }), r);\n      })\n    }, \"legends\")), D(b, {\n      defs: qe,\n      width: Xe,\n      height: ze,\n      margin: Ae,\n      role: Ce,\n      ariaLabel: Oe,\n      ariaLabelledBy: Ie,\n      ariaDescribedBy: Me,\n      children: d.map(function (e, t) {\n        var n;\n        return \"function\" == typeof e ? D(i, {\n          children: r(e, rr)\n        }, t) : null != (n = null == tr ? void 0 : tr[e]) ? n : null;\n      })\n    });\n  },\n  re = function (e) {\n    var r = e.isInteractive,\n      t = void 0 === r ? Z.isInteractive : r,\n      n = e.animate,\n      o = void 0 === n ? Z.animate : n,\n      i = e.motionConfig,\n      a = void 0 === i ? Z.motionConfig : i,\n      l = e.theme,\n      d = e.renderWrapper,\n      u = j(e, _);\n    return D(h, {\n      animate: o,\n      isInteractive: t,\n      motionConfig: a,\n      renderWrapper: d,\n      theme: l,\n      children: D(ee, z({\n        isInteractive: t\n      }, u))\n    });\n  },\n  te = function (e) {\n    return D(x, {\n      children: function (r) {\n        var t = r.width,\n          n = r.height;\n        return D(re, z({\n          width: t,\n          height: n\n        }, e));\n      }\n    });\n  };\nexport { re as Radar, U as RadarDots, te as ResponsiveRadar, Z as svgDefaultProps };","map":{"version":3,"names":["T","RadarLayer","r","t","n","data","o","item","i","colorByKey","u","fillByKey","c","radiusScale","s","rotation","f","angleStep","m","curveFactory","g","borderWidth","v","borderColor","y","fillOpacity","h","blendMode","p","a","b","W","x","e","O","radius","angle","curve","k","l","S","animate","C","config","I","d","map","M","B","fill","stroke","key","color","immediate","K","D","L","path","strokeWidth","style","mixBlendMode","E","RadarGridLabels","angles","indices","label","labelOffset","z","id","anchor","length","transform","Y","children","animated","H","G","circle","Math","max","grid","line","R","RadarGridLevelLinear","dataLength","Array","from","q","RadarGridLevels","shape","j","J","RadarGrid","levels","radii","reverse","PI","w","x1","y1","x2","y2","N","RadarSlice","datum","keys","index","formatValue","startAngle","endAngle","arcGenerator","tooltip","onClick","A","showTooltipFromEvent","hideTooltip","value","formattedValue","sort","tipX","tipY","V","F","crosshair","onMouseEnter","onMouseMove","onMouseLeave","Q","RadarSlices","getIndex","outerRadius","innerRadius","U","RadarDots","symbol","size","enableLabel","labelYOffset","reduce","forEach","push","Z","layers","maxValue","gridLevels","gridShape","gridLabelOffset","gridLabel","axis","ticks","text","dominantBaseline","textAnchor","enableDots","dotSize","dotColor","dotBorderWidth","dotBorderColor","enableDotLabel","dotLabel","dotLabelYOffset","colors","scheme","isInteractive","sliceTooltip","P","title","rows","legends","role","motionConfig","defs","$","_","ee","InnerRadar","indexBy","valueFormat","margin","width","height","dotSymbol","re","te","ne","oe","ie","ae","le","de","ue","ce","se","fe","me","ge","ve","ye","he","pe","be","xe","ke","Be","Le","Se","Ce","Oe","ariaLabel","Ie","ariaLabelledBy","Me","ariaDescribedBy","We","Ke","Ve","De","Ye","we","Ae","Fe","innerWidth","Pe","innerHeight","Xe","outerWidth","ze","outerHeight","je","rotationDegrees","boundDefs","concat","apply","min","X","range","domain","centerX","centerY","find","legendData","boundLegends","customLayerProps","Te","Ee","He","Ge","Re","qe","Je","Ne","Qe","Ue","Ze","$e","_e","er","rr","tr","slices","dots","includes","containerWidth","containerHeight","Radar","theme","renderWrapper","ResponsiveRadar","svgDefaultProps"],"sources":["/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarLayer.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarGridLabels.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarGridLevels.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarGrid.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarSlice.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarSlices.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarDots.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/props.ts","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarGridLabel.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/RadarSliceTooltip.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/Radar.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/hooks.ts","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/radar/src/ResponsiveRadar.tsx"],"sourcesContent":["import { useMemo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { lineRadial, CurveFactory } from 'd3-shape'\nimport { ScaleLinear } from 'd3-scale'\nimport { useMotionConfig, useTheme, useAnimatedPath } from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { RadarCommonProps, RadarSvgProps } from './types'\n\ninterface RadarLayerProps<D extends Record<string, unknown>> {\n    data: D[]\n    item: string\n    colorByKey: Record<string | number, string>\n    fillByKey: Record<string, string | null>\n    radiusScale: ScaleLinear<number, number>\n    rotation: number\n    angleStep: number\n    curveFactory: CurveFactory\n    borderWidth: RadarCommonProps<D>['borderWidth']\n    borderColor: RadarCommonProps<D>['borderColor']\n    fillOpacity: RadarCommonProps<D>['fillOpacity']\n    blendMode: RadarCommonProps<D>['blendMode']\n    onClick?: RadarSvgProps<D>['onClick']\n}\n\nexport const RadarLayer = <D extends Record<string, unknown>>({\n    data,\n    item: key,\n    colorByKey,\n    fillByKey,\n    radiusScale,\n    rotation,\n    angleStep,\n    curveFactory,\n    borderWidth,\n    borderColor,\n    fillOpacity,\n    blendMode,\n}: RadarLayerProps<D>) => {\n    const theme = useTheme()\n    const getBorderColor = useInheritedColor(borderColor, theme)\n\n    const lineGenerator = useMemo(() => {\n        return lineRadial<number>()\n            .radius(d => radiusScale(d))\n            .angle((_, i) => rotation + i * angleStep)\n            .curve(curveFactory)\n    }, [radiusScale, rotation, angleStep, curveFactory])\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(lineGenerator(data.map(d => d[key] as number)) as string)\n    const animatedProps = useSpring<{ fill: string; stroke: string }>({\n        fill: colorByKey[key],\n        stroke: getBorderColor({ key, color: colorByKey[key] }),\n        config: springConfig,\n        immediate: !animate,\n    })\n    const fill = fillByKey[key] ?? animatedProps.fill\n\n    return (\n        <animated.path\n            key={key}\n            d={animatedPath}\n            fill={fill}\n            fillOpacity={fillOpacity}\n            stroke={animatedProps.stroke}\n            strokeWidth={borderWidth}\n            style={{ mixBlendMode: blendMode }}\n        />\n    )\n}\n","import { createElement } from 'react'\nimport { useSprings } from '@react-spring/web'\nimport { useMotionConfig, positionFromAngle, radiansToDegrees } from '@nivo/core'\nimport { GridLabelComponent } from './types'\n\nconst textAnchorFromAngle = (_angle: number) => {\n    const angle = radiansToDegrees(_angle) + 90\n\n    if (angle <= 10 || angle >= 350 || (angle >= 170 && angle <= 190)) return 'middle' as const\n    if (angle > 180) return 'end' as const\n    return 'start' as const\n}\n\ninterface RadarGridLabelsProps {\n    radius: number\n    angles: number[]\n    indices: string[]\n    label: GridLabelComponent\n    labelOffset: number\n}\n\nexport const RadarGridLabels = ({\n    radius,\n    angles,\n    indices,\n    label: labelComponent,\n    labelOffset,\n}: RadarGridLabelsProps) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const labels = indices.map((index, i) => {\n        const position = positionFromAngle(angles[i], radius + labelOffset)\n        const textAnchor = textAnchorFromAngle(angles[i])\n\n        return {\n            id: index,\n            angle: radiansToDegrees(angles[i]),\n            anchor: textAnchor,\n            ...position,\n        }\n    })\n\n    const springs = useSprings(\n        labels.length,\n        labels.map(label => ({\n            transform: `translate(${label.x}, ${label.y})`,\n            config: springConfig,\n            immediate: !animate,\n        }))\n    )\n\n    return (\n        <>\n            {springs.map((animatedProps, index) => {\n                const label = labels[index]\n\n                return createElement(labelComponent, {\n                    key: label.id,\n                    id: label.id,\n                    anchor: label.anchor,\n                    angle: label.angle,\n                    x: label.x,\n                    y: label.y,\n                    animated: animatedProps,\n                })\n            })}\n        </>\n    )\n}\n","import { memo, SVGProps, useMemo } from 'react'\nimport { lineRadial, curveLinearClosed } from 'd3-shape'\nimport { animated, useSpring, to } from '@react-spring/web'\nimport { useTheme, useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { RadarCommonProps } from './types'\n\ninterface RadarGridLevelCircularProps {\n    radius: number\n}\n\nconst RadarGridLevelCircular = memo(({ radius }: RadarGridLevelCircularProps) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        radius,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            fill=\"none\"\n            r={to(animatedProps.radius, value => Math.max(value, 0))}\n            {...(theme.grid.line as Omit<SVGProps<SVGCircleElement>, 'ref'>)}\n        />\n    )\n})\n\ninterface RadarGridLevelLinearProps {\n    radius: number\n    rotation: number\n    angleStep: number\n    dataLength: number\n}\n\nconst RadarGridLevelLinear = ({\n    radius,\n    rotation,\n    angleStep,\n    dataLength,\n}: RadarGridLevelLinearProps) => {\n    const theme = useTheme()\n\n    const radarLineGenerator = useMemo(\n        () =>\n            lineRadial<number>()\n                .angle(i => rotation + i * angleStep)\n                .radius(radius)\n                .curve(curveLinearClosed),\n        [rotation, angleStep, radius]\n    )\n\n    const points = Array.from({ length: dataLength }, (_, i) => i)\n    const animatedPath = useAnimatedPath(radarLineGenerator(points) as string)\n\n    return (\n        <animated.path\n            fill=\"none\"\n            d={animatedPath}\n            {...(theme.grid.line as Omit<SVGProps<SVGPathElement>, 'ref'>)}\n        />\n    )\n}\n\ninterface RadarGridLevelsProps<D extends Record<string, unknown>> {\n    shape: RadarCommonProps<D>['gridShape']\n    radius: number\n    rotation: number\n    angleStep: number\n    dataLength: number\n}\n\nexport const RadarGridLevels = <D extends Record<string, unknown>>({\n    shape,\n    ...props\n}: RadarGridLevelsProps<D>) => {\n    return shape === 'circular' ? (\n        <RadarGridLevelCircular radius={props.radius} />\n    ) : (\n        <RadarGridLevelLinear {...props} />\n    )\n}\n","import { SVGProps, useMemo } from 'react'\nimport { positionFromAngle, useTheme } from '@nivo/core'\nimport { RadarGridLabels } from './RadarGridLabels'\nimport { RadarGridLevels } from './RadarGridLevels'\nimport { GridLabelComponent, RadarCommonProps } from './types'\n\ninterface RadarGridProps<D extends Record<string, unknown>> {\n    indices: string[]\n    shape: RadarCommonProps<D>['gridShape']\n    radius: number\n    levels: number\n    rotation: number\n    angleStep: number\n    label: GridLabelComponent\n    labelOffset: number\n}\n\nexport const RadarGrid = <D extends Record<string, unknown>>({\n    indices,\n    levels,\n    shape,\n    radius,\n    rotation,\n    angleStep,\n    label,\n    labelOffset,\n}: RadarGridProps<D>) => {\n    const theme = useTheme()\n    const { radii, angles } = useMemo(() => {\n        return {\n            radii: Array.from({ length: levels })\n                .map((_, i) => (radius / levels) * (i + 1))\n                .reverse(),\n            angles: Array.from({ length: indices.length }).map(\n                (_, i) => rotation + i * angleStep - Math.PI / 2\n            ),\n        }\n    }, [indices, levels, radius, rotation, angleStep])\n\n    return (\n        <>\n            {angles.map((angle, i) => {\n                const position = positionFromAngle(angle, radius)\n                return (\n                    <line\n                        key={`axis.${i}`}\n                        x1={0}\n                        y1={0}\n                        x2={position.x}\n                        y2={position.y}\n                        {...(theme.grid.line as SVGProps<SVGLineElement>)}\n                    />\n                )\n            })}\n            {radii.map((radius, i) => (\n                <RadarGridLevels<D>\n                    key={`level.${i}`}\n                    shape={shape}\n                    radius={radius}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    dataLength={indices.length}\n                />\n            ))}\n            <RadarGridLabels\n                radius={radius}\n                angles={angles}\n                indices={indices}\n                labelOffset={labelOffset}\n                label={label}\n            />\n        </>\n    )\n}\n","import { useMemo, useState, useCallback, createElement, MouseEvent } from 'react'\nimport { Arc } from 'd3-shape'\nimport { positionFromAngle, useTheme } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { RadarCommonProps, RadarDataProps, RadarSliceTooltipDatum, RadarSvgProps } from './types'\n\ninterface RadarSliceProps<D extends Record<string, unknown>> {\n    datum: D\n    keys: RadarDataProps<D>['keys']\n    index: string | number\n    formatValue: (value: number, context: string) => string\n    colorByKey: Record<string, string>\n    startAngle: number\n    endAngle: number\n    radius: number\n    arcGenerator: Arc<void, { startAngle: number; endAngle: number }>\n    tooltip: RadarCommonProps<D>['sliceTooltip']\n    onClick?: RadarSvgProps<D>['onClick']\n}\n\nexport const RadarSlice = <D extends Record<string, unknown>>({\n    datum,\n    keys,\n    index,\n    formatValue,\n    colorByKey,\n    radius,\n    startAngle,\n    endAngle,\n    arcGenerator,\n    tooltip,\n    onClick,\n}: RadarSliceProps<D>) => {\n    const [isHover, setIsHover] = useState(false)\n    const theme = useTheme()\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGPathElement>) => onClick?.(datum, event),\n        [onClick, datum]\n    )\n\n    const tooltipData = useMemo(() => {\n        const data: RadarSliceTooltipDatum[] = keys.map(key => ({\n            color: colorByKey[key],\n            id: key,\n            value: datum[key] as number,\n            formattedValue: formatValue(datum[key] as number, key),\n        }))\n        data.sort((a, b) => a.value - b.value)\n        data.reverse()\n\n        return data\n    }, [datum, keys, formatValue, colorByKey])\n\n    const showItemTooltip = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            setIsHover(true)\n            showTooltipFromEvent(\n                createElement(tooltip, {\n                    index,\n                    data: tooltipData,\n                }),\n                event\n            )\n        },\n        [showTooltipFromEvent, tooltip, index, tooltipData]\n    )\n\n    const hideItemTooltip = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [hideTooltip, setIsHover])\n\n    const { path, tipX, tipY } = useMemo(() => {\n        const position = positionFromAngle(\n            startAngle + (endAngle - startAngle) * 0.5 - Math.PI / 2,\n            radius\n        )\n\n        return {\n            path: arcGenerator({ startAngle, endAngle }) as string,\n            tipX: position.x,\n            tipY: position.y,\n        }\n    }, [startAngle, endAngle, radius, arcGenerator])\n\n    return (\n        <>\n            {isHover && <line x1={0} y1={0} x2={tipX} y2={tipY} style={theme.crosshair.line} />}\n            <path\n                d={path}\n                fill=\"#F00\"\n                fillOpacity={0}\n                onMouseEnter={showItemTooltip}\n                onMouseMove={showItemTooltip}\n                onMouseLeave={hideItemTooltip}\n                onClick={handleClick}\n            />\n        </>\n    )\n}\n","import { arc as d3Arc } from 'd3-shape'\nimport { RadarSlice } from './RadarSlice'\nimport { RadarColorMapping, RadarCommonProps, RadarDataProps, RadarSvgProps } from './types'\n\ninterface RadarSlicesProps<D extends Record<string, unknown>> {\n    data: RadarDataProps<D>['data']\n    keys: RadarDataProps<D>['keys']\n    getIndex: (d: D) => string | number\n    formatValue: (value: number, context: string) => string\n    colorByKey: RadarColorMapping\n    radius: number\n    rotation: number\n    angleStep: number\n    tooltip: RadarCommonProps<D>['sliceTooltip']\n    onClick?: RadarSvgProps<D>['onClick']\n}\n\nexport const RadarSlices = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    getIndex,\n    formatValue,\n    colorByKey,\n    radius,\n    rotation,\n    angleStep,\n    tooltip,\n    onClick,\n}: RadarSlicesProps<D>) => {\n    const arc = d3Arc<{ startAngle: number; endAngle: number }>().outerRadius(radius).innerRadius(0)\n\n    const halfAngleStep = angleStep * 0.5\n    let rootStartAngle = rotation - halfAngleStep\n\n    return (\n        <>\n            {data.map(d => {\n                const index = getIndex(d)\n                const startAngle = rootStartAngle\n                const endAngle = startAngle + angleStep\n\n                rootStartAngle += angleStep\n\n                return (\n                    <RadarSlice\n                        key={index}\n                        datum={d}\n                        keys={keys}\n                        index={index}\n                        formatValue={formatValue}\n                        colorByKey={colorByKey}\n                        startAngle={startAngle}\n                        endAngle={endAngle}\n                        radius={radius}\n                        arcGenerator={arc}\n                        tooltip={tooltip}\n                        onClick={onClick}\n                    />\n                )\n            })}\n        </>\n    )\n}\n","import { useMemo } from 'react'\nimport { ScaleLinear } from 'd3-scale'\nimport { useTheme, positionFromAngle, DotsItem, usePropertyAccessor } from '@nivo/core'\nimport { getInheritedColorGenerator } from '@nivo/colors'\nimport { RadarCommonProps, RadarDataProps, PointProps, PointData, RadarColorMapping } from './types'\n\ninterface RadarDotsProps<D extends Record<string, unknown>> {\n    data: RadarDataProps<D>['data']\n    keys: RadarDataProps<D>['keys']\n    radiusScale: ScaleLinear<number, number>\n    getIndex: (d: D) => string\n    colorByKey: RadarColorMapping\n    rotation: number\n    angleStep: number\n    symbol?: RadarCommonProps<D>['dotSymbol']\n    size: number\n    color: RadarCommonProps<D>['dotColor']\n    borderWidth: number\n    borderColor: RadarCommonProps<D>['dotBorderColor']\n    enableLabel: boolean\n    label: RadarCommonProps<D>['dotLabel']\n    formatValue: (value: number, context: string) => string\n    labelYOffset: number\n}\n\nexport const RadarDots = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    getIndex,\n    colorByKey,\n    radiusScale,\n    rotation,\n    angleStep,\n    symbol,\n    size = 6,\n    color = { from: 'color' },\n    borderWidth = 0,\n    borderColor = { from: 'color' },\n    enableLabel = false,\n    label = 'value',\n    formatValue,\n    labelYOffset,\n}: RadarDotsProps<D>) => {\n    const theme = useTheme()\n    const fillColor = getInheritedColorGenerator(color, theme)\n    const strokeColor = getInheritedColorGenerator(borderColor, theme)\n    const getLabel = usePropertyAccessor<PointData, string | number>(label)\n\n    const points: PointProps[] = useMemo(\n        () =>\n            data.reduce((acc, datum, i) => {\n                const index = getIndex(datum)\n                keys.forEach(key => {\n                    const value = datum[key] as number\n\n                    const pointData: PointData = {\n                        index,\n                        key,\n                        value,\n                        formattedValue: formatValue(value, key),\n                        color: colorByKey[key],\n                    }\n\n                    acc.push({\n                        key: `${key}.${index}`,\n                        label: enableLabel ? getLabel(pointData) : undefined,\n                        style: {\n                            fill: fillColor(pointData),\n                            stroke: strokeColor(pointData),\n                            ...positionFromAngle(\n                                rotation + angleStep * i - Math.PI / 2,\n                                radiusScale(datum[key] as number)\n                            ),\n                        },\n                        data: pointData,\n                    })\n                })\n\n                return acc\n            }, [] as PointProps[]),\n        [\n            data,\n            keys,\n            getIndex,\n            colorByKey,\n            enableLabel,\n            getLabel,\n            formatValue,\n            fillColor,\n            strokeColor,\n            rotation,\n            angleStep,\n            radiusScale,\n        ]\n    )\n\n    return (\n        <>\n            {points.map(point => (\n                <DotsItem\n                    key={point.key}\n                    x={point.style.x}\n                    y={point.style.y}\n                    symbol={symbol}\n                    size={size}\n                    color={point.style.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.style.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    datum={point.data}\n                />\n            ))}\n        </>\n    )\n}\n","import { RadarGridLabel } from './RadarGridLabel'\nimport { RadarSliceTooltip } from './RadarSliceTooltip'\nimport { RadarLayerId } from './types'\n\nexport const svgDefaultProps = {\n    layers: ['grid', 'layers', 'slices', 'dots', 'legends'] as RadarLayerId[],\n\n    maxValue: 'auto' as const,\n\n    rotation: 0,\n\n    curve: 'linearClosed' as const,\n\n    borderWidth: 2,\n    borderColor: { from: 'color' },\n\n    gridLevels: 5,\n    gridShape: 'circular' as const,\n    gridLabelOffset: 16,\n    gridLabel: RadarGridLabel,\n\n    enableDots: true,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n    enableDotLabel: false,\n    dotLabel: 'formattedValue',\n    dotLabelYOffset: -12,\n\n    colors: { scheme: 'nivo' as const },\n    fillOpacity: 0.25,\n    blendMode: 'normal' as const,\n\n    isInteractive: true,\n    sliceTooltip: RadarSliceTooltip,\n\n    legends: [],\n    role: 'img',\n\n    animate: true,\n    motionConfig: 'gentle' as const,\n\n    defs: [],\n    fill: [],\n}\n","import { animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\nimport { GridLabelProps } from './types'\n\nexport const RadarGridLabel = ({ id, anchor, animated: animatedProps }: GridLabelProps) => {\n    const theme = useTheme()\n\n    return (\n        <animated.g transform={animatedProps.transform}>\n            <text style={theme.axis.ticks.text} dominantBaseline=\"central\" textAnchor={anchor}>\n                {id}\n            </text>\n        </animated.g>\n    )\n}\n","import { useMemo } from 'react'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { RadarSliceTooltipProps } from './types'\n\nexport const RadarSliceTooltip = ({ index, data }: RadarSliceTooltipProps) => {\n    const rows = useMemo(\n        () =>\n            data.map(datum => [\n                <Chip key={datum.id} color={datum.color} />,\n                datum.id,\n                datum.formattedValue,\n            ]),\n        [data]\n    )\n\n    return <TableTooltip title={<strong>{index}</strong>} rows={rows} />\n}\n","import { ReactNode, Fragment, createElement } from 'react'\nimport { Container, useDimensions, SvgWrapper } from '@nivo/core'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { RadarLayer } from './RadarLayer'\nimport { RadarGrid } from './RadarGrid'\nimport { RadarSlices } from './RadarSlices'\nimport { RadarDots } from './RadarDots'\nimport { svgDefaultProps } from './props'\nimport { RadarLayerId, RadarSvgProps } from './types'\nimport { useRadar } from './hooks'\n\ntype InnerRadarProps<D extends Record<string, unknown>> = Omit<\n    RadarSvgProps<D>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerRadar = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    indexBy,\n    layers = svgDefaultProps.layers,\n    rotation: rotationDegrees = svgDefaultProps.rotation,\n    maxValue = svgDefaultProps.maxValue,\n    valueFormat,\n    curve = svgDefaultProps.curve,\n    margin: partialMargin,\n    width,\n    height,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor = svgDefaultProps.borderColor,\n    gridLevels = svgDefaultProps.gridLevels,\n    gridShape = svgDefaultProps.gridShape,\n    gridLabel = svgDefaultProps.gridLabel,\n    gridLabelOffset = svgDefaultProps.gridLabelOffset,\n    enableDots = svgDefaultProps.enableDots,\n    dotSymbol,\n    dotSize = svgDefaultProps.dotSize,\n    dotColor = svgDefaultProps.dotColor,\n    dotBorderWidth = svgDefaultProps.dotBorderWidth,\n    dotBorderColor = svgDefaultProps.dotBorderColor,\n    enableDotLabel = svgDefaultProps.enableDotLabel,\n    dotLabel = svgDefaultProps.dotLabel,\n    dotLabelYOffset = svgDefaultProps.dotLabelYOffset,\n    colors = svgDefaultProps.colors,\n    fillOpacity = svgDefaultProps.fillOpacity,\n    blendMode = svgDefaultProps.blendMode,\n    isInteractive = svgDefaultProps.isInteractive,\n    sliceTooltip = svgDefaultProps.sliceTooltip,\n    legends = svgDefaultProps.legends,\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n    onClick,\n}: InnerRadarProps<D>) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        getIndex,\n        indices,\n        formatValue,\n        colorByKey,\n        fillByKey,\n        boundDefs,\n        rotation,\n        radius,\n        radiusScale,\n        centerX,\n        centerY,\n        angleStep,\n        curveFactory,\n        boundLegends,\n        customLayerProps,\n    } = useRadar<D>({\n        data,\n        keys,\n        indexBy,\n        rotationDegrees,\n        maxValue,\n        valueFormat,\n        curve,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        legends,\n        defs,\n        fill,\n    })\n\n    const layerById: Record<RadarLayerId, ReactNode> = {\n        grid: null,\n        layers: null,\n        slices: null,\n        dots: null,\n        legends: null,\n    }\n\n    if (layers.includes('grid')) {\n        layerById.grid = (\n            <g key=\"grid\" transform={`translate(${centerX}, ${centerY})`}>\n                <RadarGrid<D>\n                    levels={gridLevels}\n                    shape={gridShape}\n                    radius={radius}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    indices={indices}\n                    label={gridLabel}\n                    labelOffset={gridLabelOffset}\n                />\n            </g>\n        )\n    }\n\n    if (layers.includes('layers')) {\n        layerById.layers = (\n            <g key=\"layers\" transform={`translate(${centerX}, ${centerY})`}>\n                {keys.map(key => (\n                    <RadarLayer<D>\n                        key={key}\n                        data={data}\n                        item={key}\n                        colorByKey={colorByKey}\n                        fillByKey={fillByKey}\n                        radiusScale={radiusScale}\n                        rotation={rotation}\n                        angleStep={angleStep}\n                        curveFactory={curveFactory}\n                        borderWidth={borderWidth}\n                        borderColor={borderColor}\n                        fillOpacity={fillOpacity}\n                        blendMode={blendMode}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('slices') && isInteractive) {\n        layerById.slices = (\n            <g key=\"slices\" transform={`translate(${centerX}, ${centerY})`}>\n                <RadarSlices<D>\n                    data={data}\n                    keys={keys}\n                    getIndex={getIndex}\n                    formatValue={formatValue}\n                    colorByKey={colorByKey}\n                    radius={radius}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    tooltip={sliceTooltip}\n                    onClick={onClick}\n                />\n            </g>\n        )\n    }\n\n    if (layers.includes('dots') && enableDots) {\n        layerById.dots = (\n            <g key=\"dots\" transform={`translate(${centerX}, ${centerY})`}>\n                <RadarDots<D>\n                    data={data}\n                    keys={keys}\n                    getIndex={getIndex}\n                    radiusScale={radiusScale}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    symbol={dotSymbol}\n                    size={dotSize}\n                    colorByKey={colorByKey}\n                    color={dotColor}\n                    borderWidth={dotBorderWidth}\n                    borderColor={dotBorderColor}\n                    enableLabel={enableDotLabel}\n                    label={dotLabel}\n                    formatValue={formatValue}\n                    labelYOffset={dotLabelYOffset}\n                />\n            </g>\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {boundLegends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={width}\n                        containerHeight={height}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, customLayerProps)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Radar = <D extends Record<string, unknown>>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: RadarSvgProps<D>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerRadar<D> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { useMemo } from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport {\n    // @ts-ignore\n    bindDefs,\n    useCurveInterpolation,\n    usePropertyAccessor,\n    useValueFormatter,\n} from '@nivo/core'\nimport { degreesToRadians } from '@nivo/core'\nimport { useOrdinalColorScale } from '@nivo/colors'\nimport { svgDefaultProps } from './props'\nimport {\n    RadarColorMapping,\n    RadarCommonProps,\n    RadarDataProps,\n    RadarCustomLayerProps,\n    RadarSvgProps,\n    BoundLegendProps,\n} from './types'\n\nexport const useRadar = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    indexBy,\n    rotationDegrees,\n    maxValue,\n    valueFormat,\n    curve,\n    width,\n    height,\n    colors = svgDefaultProps.colors,\n    legends,\n    defs,\n    fill,\n}: {\n    data: RadarDataProps<D>['data']\n    keys: RadarDataProps<D>['keys']\n    indexBy: RadarDataProps<D>['indexBy']\n    rotationDegrees: RadarCommonProps<D>['rotation']\n    maxValue: RadarCommonProps<D>['maxValue']\n    valueFormat?: RadarCommonProps<D>['valueFormat']\n    curve: RadarCommonProps<D>['curve']\n    width: number\n    height: number\n    colors: RadarCommonProps<D>['colors']\n    legends: RadarCommonProps<D>['legends']\n    defs: RadarSvgProps<D>['defs']\n    fill: RadarSvgProps<D>['fill']\n}) => {\n    const getIndex = usePropertyAccessor<D, string>(indexBy)\n    const indices = useMemo(() => data.map(getIndex), [data, getIndex])\n    const formatValue = useValueFormatter<number, string>(valueFormat)\n    const rotation = degreesToRadians(rotationDegrees)\n\n    const getColor = useOrdinalColorScale<{ key: string; index: number }>(colors, 'key')\n    const colorByKey: RadarColorMapping = useMemo(\n        () =>\n            keys.reduce<RadarColorMapping>((mapping, key, index) => {\n                mapping[key] = getColor({ key, index })\n                return mapping\n            }, {}),\n        [keys, getColor]\n    )\n\n    const { boundDefs, fillByKey } = useMemo(() => {\n        // expand keys into structure expected by bindDefs\n        const keyData = keys.map(k => ({ key: k, color: colorByKey[k], data, fill: null }))\n        const boundDefs = bindDefs(defs, keyData, fill)\n        const fillByKey = keyData.reduce<Record<string, string | null>>((mapping, keyDatum) => {\n            const { key: keyName, fill } = keyDatum\n            mapping[keyName] = fill\n            return mapping\n        }, {})\n\n        return { boundDefs, fillByKey }\n    }, [keys, data, defs, fill, colorByKey])\n\n    const { radius, radiusScale, centerX, centerY, angleStep } = useMemo(() => {\n        const allValues: number[] = data.reduce(\n            (acc: number[], d) => [...acc, ...keys.map(key => d[key] as number)],\n            [] as number[]\n        )\n        const computedMaxValue = maxValue !== 'auto' ? maxValue : Math.max(...allValues)\n\n        const radius = Math.min(width, height) / 2\n        const radiusScale = scaleLinear<number, number>()\n            .range([0, radius])\n            .domain([0, computedMaxValue])\n\n        return {\n            radius,\n            radiusScale,\n            centerX: width / 2,\n            centerY: height / 2,\n            angleStep: (Math.PI * 2) / data.length,\n        }\n    }, [keys, data, maxValue, width, height])\n\n    const curveFactory = useCurveInterpolation(curve)\n\n    const customLayerProps: RadarCustomLayerProps<D> = useMemo(\n        () => ({\n            data,\n            keys,\n            indices,\n            colorByKey,\n            centerX,\n            centerY,\n            radiusScale,\n            angleStep,\n        }),\n        [data, keys, indices, colorByKey, centerX, centerY, radiusScale, angleStep]\n    )\n\n    const legendData = useMemo(\n        () => keys.map(key => ({ id: key, label: key, color: colorByKey[key] })),\n        [keys, colorByKey]\n    )\n\n    const boundLegends: BoundLegendProps[] = useMemo(\n        () =>\n            legends.map(({ data: customData, ...legend }) => {\n                const boundData = customData?.map(cd => {\n                    const findData = legendData.find(ld => ld.id === cd.id) || {}\n                    return { ...findData, ...cd }\n                })\n                return { ...legend, data: boundData || legendData }\n            }),\n        [legends, legendData]\n    )\n\n    return {\n        getIndex,\n        indices,\n        formatValue,\n        colorByKey,\n        fillByKey,\n        boundDefs,\n        rotation,\n        radius,\n        radiusScale,\n        centerX,\n        centerY,\n        angleStep,\n        curveFactory,\n        legendData,\n        boundLegends,\n        customLayerProps,\n    }\n}\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { RadarSvgProps } from './types'\nimport { Radar } from './Radar'\n\nexport const ResponsiveRadar = <D extends Record<string, unknown>>(\n    props: Omit<RadarSvgProps<D>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Radar<D> width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}