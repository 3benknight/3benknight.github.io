{"ast":null,"code":"import { TableTooltip as e, useTooltip as t } from \"@nivo/tooltip\";\nimport { jsx as i } from \"react/jsx-runtime\";\nimport { useMemo as r, useRef as n, useEffect as o, useCallback as a, createElement as l, Fragment as d } from \"react\";\nimport { curveFromProp as c, useMotionConfig as u, useAnimatedPath as s, Container as v, useDimensions as h, SvgWrapper as f, ResponsiveWrapper as p, useTheme as g } from \"@nivo/core\";\nimport { Axis as m, renderAxisToCanvas as y } from \"@nivo/axes\";\nimport { BoxLegendSvg as b, renderLegendToCanvas as x } from \"@nivo/legends\";\nimport { line as w } from \"d3-shape\";\nimport { scalePoint as W, scaleLinear as k } from \"d3-scale\";\nimport { useOrdinalColorScale as S } from \"@nivo/colors\";\nimport { castPointScale as C, castLinearScale as I } from \"@nivo/scales\";\nimport { useSpring as P, animated as L } from \"@react-spring/web\";\nfunction z() {\n  return z = Object.assign ? Object.assign.bind() : function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = arguments[t];\n      for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);\n    }\n    return e;\n  }, z.apply(this, arguments);\n}\nfunction B(e, t) {\n  if (null == e) return {};\n  var i,\n    r,\n    n = {},\n    o = Object.keys(e);\n  for (r = 0; r < o.length; r++) i = o[r], t.indexOf(i) >= 0 || (n[i] = e[i]);\n  return n;\n}\nfunction D(e, t) {\n  (null == t || t > e.length) && (t = e.length);\n  for (var i = 0, r = new Array(t); i < t; i++) r[i] = e[i];\n  return r;\n}\nfunction O(e, t) {\n  var i = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (i) return (i = i.call(e)).next.bind(i);\n  if (Array.isArray(e) || (i = function (e, t) {\n    if (e) {\n      if (\"string\" == typeof e) return D(e, t);\n      var i = Object.prototype.toString.call(e).slice(8, -1);\n      return \"Object\" === i && e.constructor && (i = e.constructor.name), \"Map\" === i || \"Set\" === i ? Array.from(e) : \"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? D(e, t) : void 0;\n    }\n  }(e)) || t && e && \"number\" == typeof e.length) {\n    i && (e = i);\n    var r = 0;\n    return function () {\n      return r >= e.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: e[r++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar M,\n  j = {\n    layout: \"horizontal\",\n    curve: \"linear\",\n    role: \"img\",\n    colors: {\n      scheme: \"category10\"\n    },\n    lineWidth: 2,\n    lineOpacity: .5,\n    axesTicksPosition: \"after\",\n    isInteractive: !0,\n    tooltip: function (t) {\n      var r = t.datum,\n        n = t.variables;\n      return i(e, {\n        rows: n.map(function (e) {\n          return [e.label || e.id, i(\"strong\", {\n            children: r.data[e.value]\n          })];\n        })\n      });\n    },\n    legends: [],\n    animate: !0,\n    motionConfig: \"gentle\"\n  },\n  A = z({}, j, {\n    layers: [\"lines\", \"axes\", \"legends\"]\n  }),\n  G = z({}, j, {\n    layers: [\"lines\", \"axes\", \"legends\"],\n    pixelRatio: \"undefined\" != typeof window && null != (M = window.devicePixelRatio) ? M : 1\n  }),\n  R = function (e) {\n    var t = e.width,\n      i = e.height,\n      a = e.data,\n      l = e.variables,\n      d = e.groupBy,\n      u = e.groups,\n      s = e.layout,\n      v = void 0 === s ? j.layout : s,\n      h = e.curve,\n      f = void 0 === h ? j.curve : h,\n      p = e.colors,\n      g = void 0 === p ? j.colors : p,\n      m = e.forwardLegendData,\n      y = S(g, \"id\"),\n      b = r(function () {\n        if (void 0 !== d) return function (e) {\n          var t,\n            i = e.data,\n            r = e.groupBy,\n            n = e.predefinedGroups,\n            o = e.getColor;\n          if (void 0 !== n) t = n.map(function (e) {\n            return {\n              id: e.id,\n              label: e.label || e.id,\n              color: o(e)\n            };\n          });else {\n            for (var a, l = new Set(), d = O(i); !(a = d()).done;) {\n              var c = a.value;\n              l.add(c[r]);\n            }\n            t = Array.from(l, function (e) {\n              var t = {\n                id: e,\n                label: e\n              };\n              return z({}, t, {\n                color: o(t)\n              });\n            });\n          }\n          return t;\n        }({\n          data: a,\n          groupBy: d,\n          predefinedGroups: u,\n          getColor: y\n        });\n      }, [a, d, u, y]),\n      x = r(function () {\n        var e = l.map(function (e) {\n          return e.id;\n        });\n        return C(W().range(\"horizontal\" === v ? [0, t] : [i, 0]).domain(e));\n      }, [l, v, t, i]),\n      P = r(function () {\n        return function (e) {\n          var t = e.width,\n            i = e.height,\n            r = e.data,\n            n = e.variables,\n            o = \"horizontal\" === e.layout ? [i, 0] : [0, t];\n          return n.map(function (e) {\n            var t = r.map(function (t) {\n                return t[e.value];\n              }),\n              i = void 0 !== e.min && \"auto\" !== e.min ? e.min : Math.min.apply(Math, t),\n              n = void 0 !== e.max && \"auto\" !== e.max ? e.max : Math.max.apply(Math, t),\n              a = I(k().rangeRound(o).domain([i, n]));\n            return z({}, e, {\n              scale: a\n            });\n          });\n        }({\n          width: t,\n          height: i,\n          data: a,\n          variables: l,\n          layout: v\n        });\n      }, [t, i, a, l, v]),\n      L = r(function () {\n        return function (e) {\n          var t = e.data,\n            i = e.groupBy,\n            r = e.groups,\n            n = e.variablesScale,\n            o = e.variablesWithScale,\n            a = e.layout,\n            l = e.getColor;\n          return t.map(function (e, t) {\n            var d = o.map(function (t) {\n                return [\"horizontal\" === a ? n(t.id) : t.scale(e[t.value]), \"horizontal\" === a ? t.scale(e[t.value]) : n(t.id)];\n              }),\n              c = void 0;\n            if (void 0 !== i) {\n              var u = e[i];\n              c = null == r ? void 0 : r.find(function (e) {\n                return e.id === u;\n              });\n            }\n            var s = {\n              id: e.id,\n              index: t,\n              points: d,\n              data: e,\n              color: c ? c.color : l(e)\n            };\n            return c ? z({}, s, {\n              group: c\n            }) : s;\n          });\n        }({\n          data: a,\n          groupBy: d,\n          groups: b,\n          variablesScale: x,\n          variablesWithScale: P,\n          layout: v,\n          getColor: y\n        });\n      }, [a, d, b, x, P, v, y]),\n      B = r(function () {\n        return b ? b.map(function (e) {\n          return {\n            id: e.id,\n            label: e.label || e.id,\n            color: e.color,\n            data: e\n          };\n        }) : L.map(function (e) {\n          return {\n            id: e.id,\n            label: e.id,\n            color: e.color,\n            data: e\n          };\n        });\n      }, [b, L]),\n      D = n(m);\n    o(function () {\n      \"function\" == typeof D.current && D.current(B);\n    }, [D, B]);\n    var M = r(function () {\n        return w().curve(c(f));\n      }, [f]),\n      A = r(function () {\n        return {\n          computedData: L,\n          variables: l,\n          lineGenerator: M\n        };\n      }, [L, l, M]);\n    return {\n      variablesScale: x,\n      variablesWithScale: P,\n      computedData: L,\n      lineGenerator: M,\n      legendData: B,\n      customLayerContext: A\n    };\n  },\n  E = function (e) {\n    var r = e.datum,\n      n = e.variables,\n      o = e.lineGenerator,\n      d = e.lineWidth,\n      c = e.opacity,\n      v = e.tooltip,\n      h = e.testIdPrefix,\n      f = t(),\n      p = f.showTooltipFromEvent,\n      g = f.hideTooltip,\n      m = a(function (e) {\n        p(l(v, {\n          datum: r,\n          variables: n\n        }), e);\n      }, [p, r, n]),\n      y = u(),\n      b = y.animate,\n      x = y.config,\n      w = s(o(r.points)),\n      W = P({\n        color: r.color,\n        opacity: c,\n        config: x,\n        immediate: !b\n      });\n    return i(L.path, {\n      d: w,\n      stroke: W.color,\n      strokeWidth: d,\n      strokeLinecap: \"round\",\n      opacity: W.opacity,\n      fill: \"none\",\n      onMouseEnter: m,\n      onMouseMove: m,\n      onMouseLeave: g,\n      \"data-test-id\": h ? h + \".line_\" + r.id : void 0\n    });\n  },\n  T = [\"isInteractive\", \"animate\", \"motionConfig\", \"theme\", \"renderWrapper\"],\n  H = function (e) {\n    var t = e.data,\n      r = e.variables,\n      n = e.groupBy,\n      o = e.groups,\n      a = e.width,\n      c = e.height,\n      u = e.margin,\n      s = e.layout,\n      v = void 0 === s ? A.layout : s,\n      p = e.curve,\n      g = void 0 === p ? A.curve : p,\n      y = e.axesTicksPosition,\n      x = e.lineWidth,\n      w = void 0 === x ? A.lineWidth : x,\n      W = e.lineOpacity,\n      k = void 0 === W ? A.lineOpacity : W,\n      S = e.colors,\n      C = void 0 === S ? A.colors : S,\n      I = e.layers,\n      P = void 0 === I ? A.layers : I,\n      L = e.tooltip,\n      B = void 0 === L ? A.tooltip : L,\n      D = e.legends,\n      O = void 0 === D ? A.legends : D,\n      M = e.forwardLegendData,\n      j = e.role,\n      G = void 0 === j ? A.role : j,\n      T = e.ariaLabel,\n      H = e.ariaLabelledBy,\n      F = e.ariaDescribedBy,\n      V = e.testIdPrefix,\n      U = h(a, c, u),\n      $ = U.outerWidth,\n      _ = U.outerHeight,\n      q = U.margin,\n      J = U.innerWidth,\n      K = U.innerHeight,\n      N = R({\n        width: J,\n        height: K,\n        data: t,\n        variables: r,\n        groupBy: n,\n        groups: o,\n        layout: v,\n        colors: C,\n        curve: g,\n        forwardLegendData: M\n      }),\n      Q = N.variablesScale,\n      X = N.variablesWithScale,\n      Y = N.computedData,\n      Z = N.lineGenerator,\n      ee = N.legendData,\n      te = N.customLayerContext,\n      ie = {\n        axes: null,\n        lines: null,\n        legends: null\n      };\n    return P.includes(\"axes\") && (ie.axes = i(\"g\", {\n      children: X.map(function (e) {\n        return i(m, {\n          axis: \"horizontal\" === v ? \"y\" : \"x\",\n          length: \"horizontal\" === v ? K : J,\n          x: \"horizontal\" === v ? Q(e.id) : 0,\n          y: \"horizontal\" === v ? 0 : Q(e.id),\n          scale: e.scale,\n          ticksPosition: e.ticksPosition || y,\n          tickValues: e.tickValues,\n          tickSize: e.tickSize,\n          tickPadding: e.tickPadding,\n          tickRotation: e.tickRotation,\n          format: e.tickFormat,\n          legend: e.label || e.id,\n          legendPosition: e.legendPosition,\n          legendOffset: e.legendOffset\n        }, e.id);\n      })\n    }, \"axes\")), P.includes(\"lines\") && (ie.lines = i(\"g\", {\n      children: Y.map(function (e) {\n        return i(E, {\n          datum: e,\n          variables: r,\n          lineGenerator: Z,\n          lineWidth: w,\n          opacity: k,\n          tooltip: B,\n          testIdPrefix: V\n        }, \"\" + (\"group\" in e ? e.group.id : \"\") + e.id);\n      })\n    }, \"lines\")), P.includes(\"legends\") && (ie.legends = i(\"g\", {\n      children: O.map(function (e, t) {\n        return i(b, z({}, e, {\n          containerWidth: J,\n          containerHeight: K,\n          data: ee\n        }), t);\n      })\n    }, \"legends\")), i(f, {\n      width: $,\n      height: _,\n      margin: q,\n      role: G,\n      ariaLabel: T,\n      ariaLabelledBy: H,\n      ariaDescribedBy: F,\n      children: P.map(function (e, t) {\n        var r;\n        return \"function\" == typeof e ? i(d, {\n          children: l(e, te)\n        }, t) : null != (r = null == ie ? void 0 : ie[e]) ? r : null;\n      })\n    });\n  },\n  F = function (e) {\n    var t = e.isInteractive,\n      r = void 0 === t ? A.isInteractive : t,\n      n = e.animate,\n      o = void 0 === n ? A.animate : n,\n      a = e.motionConfig,\n      l = void 0 === a ? A.motionConfig : a,\n      d = e.theme,\n      c = e.renderWrapper,\n      u = B(e, T);\n    return i(v, {\n      animate: o,\n      isInteractive: r,\n      motionConfig: l,\n      renderWrapper: c,\n      theme: d,\n      children: i(H, z({\n        isInteractive: r\n      }, u))\n    });\n  },\n  V = function (e) {\n    return i(p, {\n      children: function (t) {\n        var r = t.width,\n          n = t.height;\n        return i(F, z({\n          width: r,\n          height: n\n        }, e));\n      }\n    });\n  },\n  U = [\"theme\", \"isInteractive\", \"animate\", \"motionConfig\", \"renderWrapper\"],\n  $ = function (e) {\n    var t = e.data,\n      r = e.layout,\n      a = void 0 === r ? G.layout : r,\n      l = e.variables,\n      d = e.groupBy,\n      c = e.groups,\n      u = e.width,\n      s = e.height,\n      v = e.margin,\n      f = e.curve,\n      p = void 0 === f ? G.curve : f,\n      m = e.colors,\n      b = void 0 === m ? G.colors : m,\n      w = e.lineOpacity,\n      W = void 0 === w ? G.lineOpacity : w,\n      k = e.lineWidth,\n      S = void 0 === k ? G.lineWidth : k,\n      C = e.axesTicksPosition,\n      I = void 0 === C ? G.axesTicksPosition : C,\n      P = e.legends,\n      L = void 0 === P ? G.legends : P,\n      B = e.forwardLegendData,\n      D = e.layers,\n      O = void 0 === D ? G.layers : D,\n      M = e.role,\n      j = void 0 === M ? G.role : M,\n      A = e.ariaLabel,\n      E = e.ariaLabelledBy,\n      T = e.ariaDescribedBy,\n      H = e.pixelRatio,\n      F = void 0 === H ? G.pixelRatio : H,\n      V = n(null),\n      U = h(u, s, v),\n      $ = U.margin,\n      _ = U.innerWidth,\n      q = U.innerHeight,\n      J = U.outerWidth,\n      K = U.outerHeight,\n      N = R({\n        width: _,\n        height: q,\n        data: t,\n        variables: l,\n        groupBy: d,\n        groups: c,\n        layout: a,\n        colors: b,\n        curve: p,\n        forwardLegendData: B\n      }),\n      Q = N.variablesScale,\n      X = N.variablesWithScale,\n      Y = N.computedData,\n      Z = N.lineGenerator,\n      ee = N.legendData,\n      te = N.customLayerContext,\n      ie = g();\n    return o(function () {\n      if (null !== V.current) {\n        var e = V.current.getContext(\"2d\");\n        null !== e && (V.current.width = J * F, V.current.height = K * F, e.scale(F, F), e.fillStyle = ie.background, e.fillRect(0, 0, J, K), e.translate($.left, $.top), O.forEach(function (t) {\n          \"axes\" === t ? X.forEach(function (t) {\n            y(e, {\n              axis: \"horizontal\" === a ? \"y\" : \"x\",\n              scale: t.scale,\n              x: \"horizontal\" === a ? Q(t.id) : 0,\n              y: \"horizontal\" === a ? 0 : Q(t.id),\n              length: \"horizontal\" === a ? q : _,\n              ticksPosition: I,\n              theme: ie\n            });\n          }) : \"lines\" === t ? (Z.context(e), Y.forEach(function (t) {\n            e.save(), e.globalAlpha = W, e.beginPath(), Z(t.points), e.strokeStyle = t.color, e.lineWidth = S, e.stroke(), e.restore();\n          })) : \"legends\" === t ? L.forEach(function (t) {\n            x(e, z({}, t, {\n              data: ee,\n              containerWidth: _,\n              containerHeight: q,\n              theme: ie\n            }));\n          }) : \"function\" == typeof t && t(e, te);\n        }));\n      }\n    }, [V, J, K, _, q, $, O, te, Z, W, S, Y, Q, X, a, I, L, ee, ie, F]), i(\"canvas\", {\n      ref: V,\n      width: J * F,\n      height: K * F,\n      style: {\n        width: J,\n        height: K\n      },\n      role: j,\n      \"aria-label\": A,\n      \"aria-labelledby\": E,\n      \"aria-describedby\": T\n    });\n  },\n  _ = function (e) {\n    var t = e.theme,\n      r = e.isInteractive,\n      n = void 0 === r ? G.isInteractive : r,\n      o = e.animate,\n      a = void 0 === o ? G.animate : o,\n      l = e.motionConfig,\n      d = void 0 === l ? G.motionConfig : l,\n      c = e.renderWrapper,\n      u = B(e, U);\n    return i(v, {\n      isInteractive: n,\n      animate: a,\n      motionConfig: d,\n      theme: t,\n      renderWrapper: c,\n      children: i($, z({\n        isInteractive: n\n      }, u))\n    });\n  },\n  q = function (e) {\n    return i(p, {\n      children: function (t) {\n        var r = t.width,\n          n = t.height;\n        return i(_, z({\n          width: r,\n          height: n\n        }, e));\n      }\n    });\n  };\nexport { $ as InnerParallelCoordinatesCanvas, F as ParallelCoordinates, _ as ParallelCoordinatesCanvas, V as ResponsiveParallelCoordinates, q as ResponsiveParallelCoordinatesCanvas, G as canvasDefaultProps, j as commonDefaultProps, A as svgDefaultProps };","map":{"version":3,"names":["M","j","layout","curve","role","colors","scheme","lineWidth","lineOpacity","axesTicksPosition","isInteractive","tooltip","t","r","datum","n","variables","i","e","rows","map","label","id","children","data","value","legends","animate","motionConfig","A","z","layers","G","pixelRatio","window","devicePixelRatio","R","useParallelCoordinates","width","height","a","l","d","groupBy","u","groups","s","v","h","f","p","g","m","forwardLegendData","y","S","b","predefinedGroups","o","getColor","color","Set","O","done","c","add","Array","from","x","C","W","range","domain","P","min","Math","apply","max","I","k","rangeRound","scale","L","variablesScale","variablesWithScale","find","index","points","group","B","D","current","w","computedData","lineGenerator","legendData","customLayerContext","E","ParallelCoordinatesLine","opacity","testIdPrefix","showTooltipFromEvent","hideTooltip","config","immediate","path","stroke","strokeWidth","strokeLinecap","fill","onMouseEnter","onMouseMove","onMouseLeave","T","H","InnerParallelCoordinates","margin","ariaLabel","ariaLabelledBy","F","ariaDescribedBy","V","U","$","outerWidth","_","outerHeight","q","J","innerWidth","K","innerHeight","N","Q","X","Y","Z","ee","te","ie","axes","lines","includes","axis","length","ticksPosition","tickValues","tickSize","tickPadding","tickRotation","format","tickFormat","legend","legendPosition","legendOffset","containerWidth","containerHeight","ParallelCoordinates","theme","renderWrapper","ResponsiveParallelCoordinates","InnerParallelCoordinatesCanvas","getContext","fillStyle","background","fillRect","translate","left","top","forEach","context","save","globalAlpha","beginPath","strokeStyle","restore","ref","style","ParallelCoordinatesCanvas","ResponsiveParallelCoordinatesCanvas","canvasDefaultProps","commonDefaultProps","svgDefaultProps"],"sources":["/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/ParallelCoordinatesLineTooltip.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/defaults.ts","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/hooks.ts","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/svg/ParallelCoordinatesLine.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/svg/ParallelCoordinates.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/svg/ResponsiveParallelCoordinates.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/canvas/ParallelCoordinatesCanvas.tsx","/Users/benjaminknight/Documents/UMD/CMSC734/nivo-charts/node_modules/@nivo/parallel-coordinates/src/canvas/ResponsiveParallelCoordinatesCanvas.tsx"],"sourcesContent":["import { TableTooltip } from '@nivo/tooltip'\nimport { BaseDatum, TooltipProps, DatumGroupKeys } from './types'\n\nexport const ParallelCoordinatesLineTooltip = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    datum,\n    variables,\n}: TooltipProps<Datum, GroupBy>) => {\n    return (\n        <TableTooltip\n            rows={variables.map(variable => [\n                variable.label || variable.id,\n                <strong>{datum.data[variable.value] as number}</strong>, // eslint-disable-line react/jsx-key\n            ])}\n        />\n    )\n}\n","import { CommonProps, BaseDatum, LayerId } from './types'\nimport { ParallelCoordinatesLineTooltip } from './ParallelCoordinatesLineTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonProps<BaseDatum>,\n    | 'groupBy'\n    | 'groups'\n    | 'margin'\n    | 'theme'\n    | 'forwardLegendData'\n    | 'renderWrapper'\n    | 'ariaLabel'\n    | 'ariaLabelledBy'\n    | 'ariaDescribedBy'\n> = {\n    layout: 'horizontal',\n    curve: 'linear',\n\n    role: 'img',\n\n    colors: { scheme: 'category10' },\n    lineWidth: 2,\n    lineOpacity: 0.5,\n\n    axesTicksPosition: 'after',\n\n    isInteractive: true,\n    tooltip: ParallelCoordinatesLineTooltip,\n\n    legends: [],\n\n    animate: true,\n    motionConfig: 'gentle',\n}\n\nexport const svgDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n}\n\nexport const canvasDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1,\n}\n","import { useMemo, useRef, useEffect } from 'react'\nimport { line } from 'd3-shape'\nimport { scaleLinear, scalePoint } from 'd3-scale'\nimport { curveFromProp } from '@nivo/core'\nimport { OrdinalColorScaleConfig, useOrdinalColorScale } from '@nivo/colors'\nimport { castPointScale, castLinearScale, ScalePoint } from '@nivo/scales'\nimport {\n    Variable,\n    VariableWithScale,\n    CommonProps,\n    ComputedDatum,\n    BaseDatum,\n    BaseGroup,\n    Group,\n    CustomLayerProps,\n    GroupLegend,\n    DatumLegend,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from './types'\nimport { commonDefaultProps } from './defaults'\n\n/**\n * Compute groups.\n *\n * Please note that we assume that `groupBy` is defined, and correct, at this stage.\n *\n * If `predefinedGroups` is provided, we'll use it as a base, otherwise\n * we're going to scan each datum and extract their group, and then\n * make those unique to define the available groups.\n */\nconst computeGroups = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    predefinedGroups,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy: DatumGroupKeys<Datum>\n    predefinedGroups?: readonly BaseGroup[]\n    getColor: (group: BaseGroup) => string\n}): Group[] => {\n    let groups: Group[]\n\n    if (predefinedGroups !== undefined) {\n        groups = predefinedGroups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: getColor(group),\n        }))\n    } else {\n        const groupsSet = new Set<string>()\n        for (const datum of data) {\n            groupsSet.add(datum[groupBy] as string)\n        }\n\n        groups = Array.from(groupsSet, groupId => {\n            const group: BaseGroup = {\n                id: groupId,\n                label: groupId,\n            }\n\n            return {\n                ...group,\n                color: getColor(group),\n            }\n        })\n    }\n\n    return groups\n}\n\n/**\n * Compute the scale for each variable.\n *\n * We only support linear scales.\n *\n * Each scale domain will be computed automatically if `min`/`max` = `'auto'`,\n * otherwise, we'll use the provided values.\n */\nconst computeVariablesScales = <Datum extends BaseDatum>({\n    width,\n    height,\n    data,\n    variables,\n    layout,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    layout: CommonProps<Datum>['layout']\n}): readonly VariableWithScale<Datum>[] => {\n    // Depending on the layout, the range might need to be switched.\n    const range = layout === 'horizontal' ? [height, 0] : [0, width]\n\n    return variables.map(variable => {\n        const allValues: number[] = data.map(datum => datum[variable.value] as number)\n\n        const min =\n            variable.min !== undefined && variable.min !== 'auto'\n                ? variable.min\n                : Math.min(...allValues!)\n        const max =\n            variable.max !== undefined && variable.max !== 'auto'\n                ? variable.max\n                : Math.max(...allValues!)\n\n        const scale = castLinearScale(scaleLinear().rangeRound(range).domain([min, max]))\n\n        return { ...variable, scale }\n    })\n}\n\nconst computeDataVariables = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    groups,\n    variablesScale,\n    variablesWithScale,\n    layout,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy?: DatumGroupKeys<Datum>\n    groups: Group[] | undefined\n    variablesScale: ScalePoint<string>\n    variablesWithScale: readonly VariableWithScale<Datum>[]\n    layout: CommonProps<Datum>['layout']\n    getColor: (datum: Datum) => string\n}): ComputedDatum<Datum>[] | ComputedGroupDatum<Datum>[] => {\n    return data.map((datum, index) => {\n        const points: [number, number][] = variablesWithScale.map(variable => [\n            layout === 'horizontal'\n                ? variablesScale(variable.id)!\n                : variable.scale(datum[variable.value] as number),\n            layout === 'horizontal'\n                ? variable.scale(datum[variable.value] as number)\n                : variablesScale(variable.id)!,\n        ])\n\n        let group: Group | undefined = undefined\n        if (groupBy !== undefined) {\n            const datumGroup = datum[groupBy]\n            group = groups?.find(candidateGroup => candidateGroup.id === datumGroup)\n        }\n\n        const computedDatum: ComputedDatum<Datum> = {\n            id: datum.id,\n            index,\n            points,\n            data: datum,\n            color: group ? group.color : getColor(datum),\n        }\n\n        if (!group) return computedDatum\n\n        return {\n            ...computedDatum,\n            group,\n        } as ComputedGroupDatum<Datum>\n    })\n}\n\nexport const useParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    width,\n    height,\n    data,\n    variables,\n    groupBy,\n    groups: predefinedGroups,\n    layout = commonDefaultProps.layout,\n    curve = commonDefaultProps.curve,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<\n        IfGrouped<Datum, GroupBy, BaseGroup, Datum>\n    >,\n    forwardLegendData,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    groupBy?: CommonProps<Datum, GroupBy>['groupBy']\n    groups?: CommonProps<Datum, GroupBy>['groups']\n    layout: CommonProps<Datum, GroupBy>['layout']\n    curve: CommonProps<Datum, GroupBy>['curve']\n    colors: CommonProps<Datum, GroupBy>['colors']\n    forwardLegendData?: CommonProps<Datum, GroupBy>['forwardLegendData']\n}) => {\n    // If no groups, we'll use the data to define the color, otherwise the groups,\n    // meaning that `id` refers to either `Datum.id` or `Group.id`.\n    const getColor = useOrdinalColorScale(colors, 'id')\n\n    const groups = useMemo(() => {\n        if (groupBy === undefined) return undefined\n\n        return computeGroups<Datum>({\n            data,\n            groupBy,\n            predefinedGroups,\n            getColor: getColor as (group: BaseGroup) => string,\n        })\n    }, [data, groupBy, predefinedGroups, getColor])\n\n    const variablesScale = useMemo(() => {\n        const variableIds = variables.map(({ id }) => id)\n        return castPointScale(\n            scalePoint()\n                .range(layout === 'horizontal' ? [0, width] : [height, 0])\n                .domain(variableIds)\n        )\n    }, [variables, layout, width, height])\n\n    const variablesWithScale = useMemo(\n        () =>\n            computeVariablesScales<Datum>({\n                width,\n                height,\n                data,\n                variables,\n                layout,\n            }),\n        [width, height, data, variables, layout]\n    )\n\n    const computedData = useMemo(\n        () =>\n            computeDataVariables<Datum>({\n                data,\n                groupBy,\n                groups,\n                variablesScale,\n                variablesWithScale,\n                layout,\n                getColor,\n            }),\n        [data, groupBy, groups, variablesScale, variablesWithScale, layout, getColor]\n    )\n\n    const legendData = useMemo(() => {\n        if (!groups) {\n            return computedData.map(datum => ({\n                id: datum.id,\n                label: datum.id,\n                color: datum.color,\n                data: datum,\n            })) as DatumLegend<Datum>[]\n        }\n\n        return groups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: group.color,\n            data: group,\n        })) as GroupLegend[]\n    }, [groups, computedData])\n\n    // Forward the legends data if `forwardLegendData` is defined.\n    const forwardLegendDataRef = useRef(forwardLegendData)\n    useEffect(() => {\n        if (typeof forwardLegendDataRef.current !== 'function') return\n        forwardLegendDataRef.current(\n            legendData as IfGrouped<Datum, GroupBy, GroupLegend[], DatumLegend<Datum>[]>\n        )\n    }, [forwardLegendDataRef, legendData])\n\n    const lineGenerator = useMemo(\n        () => line<[number, number]>().curve(curveFromProp(curve)),\n        [curve]\n    )\n\n    const customLayerContext: CustomLayerProps<Datum> = useMemo(\n        () => ({\n            computedData,\n            variables,\n            lineGenerator,\n        }),\n        [computedData, variables, lineGenerator]\n    )\n\n    return {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    }\n}\n","import { useCallback, MouseEvent, createElement } from 'react'\nimport { Line } from 'd3-shape'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport {\n    BaseDatum,\n    ComputedDatum,\n    Variable,\n    TooltipComponent,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from '../types'\n\nexport const ParallelCoordinatesLine = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    datum,\n    variables,\n    lineGenerator,\n    lineWidth,\n    opacity,\n    tooltip,\n    testIdPrefix,\n}: {\n    datum: IfGrouped<Datum, GroupBy, ComputedGroupDatum<Datum>, ComputedDatum<Datum>>\n    variables: readonly Variable<Datum>[]\n    lineGenerator: Line<[number, number]>\n    lineWidth: number\n    opacity: number\n    tooltip: TooltipComponent<Datum, GroupBy>\n    testIdPrefix?: string\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { datum, variables }), event)\n        },\n        [showTooltipFromEvent, datum, variables]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(lineGenerator(datum.points)!)\n    const animatedProps = useSpring({\n        color: datum.color,\n        opacity,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            stroke={animatedProps.color}\n            strokeWidth={lineWidth}\n            strokeLinecap=\"round\"\n            opacity={animatedProps.opacity}\n            fill=\"none\"\n            onMouseEnter={handleMouseHover}\n            onMouseMove={handleMouseHover}\n            onMouseLeave={hideTooltip}\n            data-test-id={testIdPrefix ? `${testIdPrefix}.line_${datum.id}` : undefined}\n        />\n    )\n}\n","import { createElement, Fragment, ReactNode } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { Axis } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { svgDefaultProps } from '../defaults'\nimport { useParallelCoordinates } from '../hooks'\nimport {\n    ParallelCoordinatesProps,\n    BaseDatum,\n    LayerId,\n    DatumGroupKeys,\n    TooltipComponent,\n    IfGrouped,\n    ComputedGroupDatum,\n    ComputedDatum,\n} from '../types'\nimport { ParallelCoordinatesLine } from './ParallelCoordinatesLine'\n\ntype InnerParallelCoordinatesProps<\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n> = Omit<\n    ParallelCoordinatesProps<Datum, GroupBy>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    data,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    layout = svgDefaultProps.layout,\n    curve = svgDefaultProps.curve,\n    axesTicksPosition,\n    lineWidth = svgDefaultProps.lineWidth,\n    lineOpacity = svgDefaultProps.lineOpacity,\n    colors = svgDefaultProps.colors,\n    layers = svgDefaultProps.layers,\n    tooltip = svgDefaultProps.tooltip as unknown as TooltipComponent<Datum, GroupBy>,\n    legends = svgDefaultProps.legends,\n    forwardLegendData,\n    role = svgDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    testIdPrefix,\n}: InnerParallelCoordinatesProps<Datum, GroupBy>) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<Datum, GroupBy>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const layerById: Record<LayerId, ReactNode> = {\n        axes: null,\n        lines: null,\n        legends: null,\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <g key=\"axes\">\n                {variablesWithScale.map(variable => (\n                    <Axis\n                        key={variable.id}\n                        axis={layout === 'horizontal' ? 'y' : 'x'}\n                        length={layout === 'horizontal' ? innerHeight : innerWidth}\n                        x={layout === 'horizontal' ? variablesScale(variable.id) : 0}\n                        y={layout === 'horizontal' ? 0 : variablesScale(variable.id)}\n                        scale={variable.scale}\n                        ticksPosition={variable.ticksPosition || axesTicksPosition}\n                        tickValues={variable.tickValues}\n                        tickSize={variable.tickSize}\n                        tickPadding={variable.tickPadding}\n                        tickRotation={variable.tickRotation}\n                        format={variable.tickFormat}\n                        legend={variable.label || variable.id}\n                        legendPosition={variable.legendPosition}\n                        legendOffset={variable.legendOffset}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <g key=\"lines\">\n                {computedData.map(datum => (\n                    <ParallelCoordinatesLine<Datum, GroupBy>\n                        key={`${'group' in datum ? datum.group.id : ''}${datum.id}`}\n                        datum={\n                            datum as IfGrouped<\n                                Datum,\n                                GroupBy,\n                                ComputedGroupDatum<Datum>,\n                                ComputedDatum<Datum>\n                            >\n                        }\n                        variables={variables}\n                        lineGenerator={lineGenerator}\n                        lineWidth={lineWidth}\n                        opacity={lineOpacity}\n                        tooltip={tooltip}\n                        testIdPrefix={testIdPrefix}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <g key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legendData}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, customLayerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const ParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesProps<Datum, GroupBy>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerParallelCoordinates<Datum, GroupBy> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { ParallelCoordinatesProps, BaseDatum, DatumGroupKeys } from '../types'\nimport { ParallelCoordinates } from './ParallelCoordinates'\n\nexport const ResponsiveParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>(\n    props: Omit<ParallelCoordinatesProps<Datum, GroupBy>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinates<Datum, GroupBy> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import { useEffect, useRef } from 'react'\nimport { Container, useDimensions, useTheme } from '@nivo/core'\nimport { renderAxisToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useParallelCoordinates } from '../hooks'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { canvasDefaultProps } from '../defaults'\n\ntype InnerParallelCoordinatesCanvasProps<D extends BaseDatum> = Omit<\n    ParallelCoordinatesCanvasProps<D>,\n    'renderWrapper' | 'theme'\n>\n\nexport const InnerParallelCoordinatesCanvas = <D extends BaseDatum>({\n    data,\n    layout = canvasDefaultProps.layout,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    curve = canvasDefaultProps.curve,\n    colors = canvasDefaultProps.colors,\n    lineOpacity = canvasDefaultProps.lineOpacity,\n    lineWidth = canvasDefaultProps.lineWidth,\n    axesTicksPosition = canvasDefaultProps.axesTicksPosition,\n    legends = canvasDefaultProps.legends,\n    forwardLegendData,\n    layers = canvasDefaultProps.layers,\n    role = canvasDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n}: InnerParallelCoordinatesCanvasProps<D>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<D>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const theme = useTheme()\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        const ctx = canvasEl.current.getContext('2d')\n        if (ctx === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (layer === 'axes') {\n                variablesWithScale.forEach(variable => {\n                    renderAxisToCanvas(ctx, {\n                        axis: layout === 'horizontal' ? 'y' : 'x',\n                        scale: variable.scale,\n                        x: layout === 'horizontal' ? variablesScale(variable.id) : 0,\n                        y: layout === 'horizontal' ? 0 : variablesScale(variable.id),\n                        length: layout === 'horizontal' ? innerHeight : innerWidth,\n                        ticksPosition: axesTicksPosition,\n                        theme,\n                    })\n                })\n            } else if (layer === 'lines') {\n                lineGenerator.context(ctx)\n\n                computedData.forEach(datum => {\n                    ctx.save()\n                    ctx.globalAlpha = lineOpacity\n\n                    ctx.beginPath()\n                    lineGenerator(datum.points)\n                    ctx.strokeStyle = datum.color\n                    ctx.lineWidth = lineWidth\n                    ctx.stroke()\n\n                    ctx.restore()\n                })\n            } else if (layer === 'legends') {\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            } else if (typeof layer === 'function') {\n                layer(ctx, customLayerContext)\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        innerWidth,\n        innerHeight,\n        margin,\n        layers,\n        customLayerContext,\n        lineGenerator,\n        lineOpacity,\n        lineWidth,\n        computedData,\n        variablesScale,\n        variablesWithScale,\n        layout,\n        axesTicksPosition,\n        legends,\n        legendData,\n        theme,\n        pixelRatio,\n    ])\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n            }}\n            role={role}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledBy}\n            aria-describedby={ariaDescribedBy}\n        />\n    )\n}\n\nexport const ParallelCoordinatesCanvas = <D extends BaseDatum>({\n    theme,\n    isInteractive = canvasDefaultProps.isInteractive,\n    animate = canvasDefaultProps.animate,\n    motionConfig = canvasDefaultProps.motionConfig,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesCanvasProps<D>) => (\n    <Container {...{ isInteractive, animate, motionConfig, theme, renderWrapper }}>\n        <InnerParallelCoordinatesCanvas<D> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { ParallelCoordinatesCanvas } from './ParallelCoordinatesCanvas'\n\nexport const ResponsiveParallelCoordinatesCanvas = <D extends BaseDatum>(\n    props: Omit<ParallelCoordinatesCanvasProps<D>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinatesCanvas<D> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}